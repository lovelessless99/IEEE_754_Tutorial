---
title: æ·±å…¥äº†è§£æµ®é»æ•¸ IEEE 754  
date: 2021-05-13   
description: èªè­˜ IEEE 754ï¼Œæ·±å…¥äº†è§£æµ®é»æ•¸ 
categories:
 - IEEE 754
author: Lawrence
tags: 
   - IEEE 754
---
# è«‹åƒè€ƒæœ¬äººçš„ç¶²ç«™
[coding-hub IEEE ](https://lovelessless99.github.io/coding-hub/views/IEEE%20754/IEEE754.html#chapter-0-%E5%BC%95%E8%A8%80-%E5%A5%87%E6%80%AA%E7%9A%84%E6%B5%AE%E9%BB%9E%E6%95%B8%E9%81%8B%E7%AE%97)

# æ·±å…¥äº†è§£æµ®é»æ•¸ IEEE 754

## Chapter 0. å¼•è¨€ - å¥‡æ€ªçš„æµ®é»æ•¸é‹ç®—
é¦–å…ˆï¼Œå…ˆä¾†å€‹å°å°éœ‡æ’¼æ•™è‚²å§
:::: tabs
::: tab python
```python
print( f"0.1 + 0.7 = {0.1 + 0.7}")
print( f"0.1 + 0.2 = {0.1 + 0.2}")
```
:::

::: tab console
```
0.1 + 0.7 = 0.7999999999999999
0.1 + 0.2 = 0.30000000000000004
```
:::
::::

ç‚ºä»€éº¼æœƒè·Ÿæˆ‘å€‘æƒ³çš„æœ‰é»è½å·®å‘¢ ? é€™é‚Šå…ˆç ´é¡Œä¸€ä¸‹ï¼ŒåŸå› æ˜¯å› ç‚ºæˆ‘å€‘åœ¨é›»è…¦è£¡é¢ ==åªæœ‰æœ‰é™ä½å…ƒ(32 bits æˆ– 64 bits)å»è¡¨ç¤ºæ•¸å­—ï¼Œåœ¨æµ®é»æ•¸çš„è¨ˆç®—æ™‚æœƒæ¨å»ä¸€äº›ç²¾åº¦ï¼Œé€ æˆè¨ˆç®—çš„èª¤å·®==ï¼Œæ¥ä¸‹ä¾†å°±ä¾†ä»‹ç´¹æµ®é»æ•¸çš„è¾£äº›äº‹æƒ…ğŸ˜€
::: warning
åœ¨æœ¬æ–‡ä¸­ï¼Œä»¥ 32 ä½å…ƒæµ®é»æ•¸ç‚ºä¾‹å­
:::


## Chapter 1 : IEEE 754 32 bits format

### 1.1 IEEE 754 æ ¼å¼ä»‹ç´¹
![float](https://miro.medium.com/max/938/1*Av9PTaY6p8dnJrk6uzYQLQ.png)

* signï¼šæœ€å·¦å´çš„ 1 bit ä»£è¡¨æ­£è² è™Ÿï¼Œæ­£æ•¸çš„è©± sign å°±ç‚º 0ï¼Œåä¹‹å‰‡æ˜¯ 1
* exponentï¼šä¸­é–“çš„ 8 bit ä»£è¡¨æ­£è¦åŒ–å¾Œçš„æ¬¡æ–¹æ•¸ï¼Œæ¡ç”¨çš„æ˜¯ è¶…127 æ ¼å¼ï¼Œä¹Ÿå°±æ˜¯ 3 é‚„è¦åŠ ä¸Š 127 = 130
* fractionï¼šæœ€å³å´çš„ 23 bit æ”¾çš„æ˜¯å°æ•¸éƒ¨åˆ†ï¼Œä»¥ 1.0001 ä¾†èªªå°±æ˜¯å»æ‰ 1. ä¹‹å¾Œçš„ 0001

::: tip
ç­‰ç­‰æœƒé—¡è¿°ç‚ºä½•è¦ +127 çš„ bias
:::


ä¾‹å¦‚è¦è¡¨ç¤º 8.5 çš„è©±
![](https://miro.medium.com/max/878/1*JqRzcCeJp3FnbixVwSi1UQ.png)

::: tip
é€™å…©å€‹ç¾éº—çš„åœ–ç‰‡è·Ÿæ•˜è¿°ä¾†è‡ª[é€™å€‹ç¶²ç«™](https://medium.com/starbugs/see-why-floating-point-error-can-not-be-avoided-from-ieee-754-809720b32175)
:::

å¦å¤–ï¼Œä»¥ 0.1ç‚ºä¾‹çš„è©±ï¼Œä¾†çœ‹çœ‹æˆ‘ç•«çš„ç¾éº—çš„æµç¨‹å§ğŸ˜€
```mermaid
graph TD
    dec(0.1) --ä»¥2ç‚ºåº•--> bin(0.00010011001100110011001101);
    bin --ç§‘å­¸è¨˜è™Ÿ--> sci(1.0011001100110011001101 x  2 ^-4 )
    sci -- IEEE754 æ ¼å¼ --> IEEE754(0 01111011 10011001100110011001101)
    IEEE754 --Sign--> sign(0)
    IEEE754 --Exponent--> exp(01111011)
    IEEE754 --mantissa--> mantissa(10011001100110011001101)
    sign --> s(+)
    exp --> cas(127 + -4)
    mantissa --> frac(1.60000002384185791015625)
    frac --ä¸å­˜æœ€å‰é¢çš„ 1 ç‚ºäº†å¤šå­˜ä¸€ä½ç²¾åº¦--> act(0.60000002384185791015625)
```
å…©é»å†æ¬¡æ³¨æ„
* IEEE 754 å­˜æ”¾æŒ‡æ•¸ä½(Exponent)æ™‚ï¼Œæœƒ ==æŠŠæŒ‡æ•¸åš + 127 bias== çš„å‹•ä½œ
* å­˜æ”¾å°æ•¸ä½(fraction or mantissa)æ™‚ï¼Œ==ä¸æœƒå­˜æœ€å‰é¢çš„ 1ï¼Œç‚ºäº†å¤šå­˜ä¸€ä½ç²¾åº¦ï¼Œä½†è¦æ›ç®—å›åŸä¾†çš„æ•¸æ™‚è¦è¨˜å¾—åŠ å›ä¾†==

### 1.2 ç¨‹å¼ç¢¼ç¯„ä¾‹
æ¥ä¸‹ä¾†å°±ä¾†å…©å€‹ä¾‹å­ï¼Œé¦–å…ˆä¾†å€‹ç°¡å–®çš„ 1.0
:::: tabs
::: tab python
```python
import bitstring
f1 = bitstring.BitArray(float=1.0, length=32)
sign = f1.bin[0]   # 1 bit
exp  = f1.bin[1:9] # 8 bits
frac = f1.bin[9:]  # 23 bits
print(sign, exp, frac)
```
:::

::: tab console
```
0 01111111 00000000000000000000000
```
:::

::::

å¯ä»¥æƒ³åƒçš„åˆ°ï¼Œå› ç‚º $1.0 = 2^{0}$ ï¼Œæ‰€ä»¥ $0 + 127(bias)= 127 = 01111111_{2}$

æ¥ä¸‹ä¾†æ˜¯æ¯”è¼ƒå›°é›£çš„ 0.1äº†ï¼Œæˆ‘å€‘è¦ä¾† ==é€†æ¨==
:::: tabs
::: tab python
```python
# è¨ˆç®— 0.1 çš„äºŒé€²ä½
frac = "10011001100110011001101"
value = 0
start = 1 # å¾ 1/2 ^ 1 é–‹å§‹
for bit in frac:
        value += int(bit) * 0.5 ** start
        start += 1
print( f"fraction :  { value + 1 }")
print( f"Value actually stored in float  :  { (value + 1) * 2 ** ( 123 - 127) }")
```
:::

::: tab console
```
fraction :  1.600000023841858
Value actually stored in float  :  0.10000000149011612
```
:::

::::
å›æ¨éç¨‹å¦‚ä¸‹
1. å› ç‚ºå‰é¢æ‰€çœ‹åˆ°ï¼Œ0.1 çš„IEEE 754 æŒ‡æ•¸ä½ç‚º $01111011_{2} = 123 = 127 + (-4)$ï¼Œæ¨å¾— -4 æ˜¯åŸä¾†çš„æŒ‡æ•¸
2. å†ä¾†å› ç‚ºæˆ‘å€‘åœ¨å„²å­˜fractionæ¬„ä½æ™‚æŠŠæœ€å‰é¢çš„ 1 çµ¦æ¨å»ç‚ºäº†å„²å­˜å¤šä¸€ä½çš„ç²¾åº¦ï¼Œæ‰€ä»¥æ¨å›ä¾†æ™‚è¦å†åŠ å›ä¾†
å› æ­¤ $fraction = 1_{10} + 10011001100110011001101_{2} = 1_{10} + 0.600000023841858_{10}$
3. æœ€å¾Œæˆ‘å€‘å¯¦éš›ä¸Šæ‰€å„²å­˜çš„ 32 bitsçš„ 0.1 å°±æ˜¯ $1.600000023841858\times2^{-4}=0.10000000149011612$

å› æ­¤ï¼Œèˆ‡æˆ‘å€‘ç†æƒ³ä¸­çš„ 0.1 çœŸçš„æœ‰äº›èª¤å·®ï¼Œèª¤å·®å‡ºç¾çš„åœ°æ–¹æ˜¯å°‡åé€²åˆ¶è½‰æˆäºŒé€²åˆ¶æ™‚ï¼Œæˆ‘å€‘åªæœ‰æœ‰é™çš„bitsè¡¨ç¤ºæµ®é»æ•¸ï¼Œè€Œåœ¨ C èªè¨€çš„ printf é è¨­é¡¯ç¤ºç²¾åº¦æ˜¯6ä½æ•¸ï¼Œæ‰€ä»¥ä½ printf 0.1æ™‚æœƒæ˜¯ 0.100000
å¥½ï¼Œä»‹ç´¹å®Œæµ®é»æ•¸çš„èª¤å·®ä¾†æºå¾Œï¼Œå°±ä¾†è§£æƒ‘ä¸€ä¸‹ ==ç‚ºä»€éº¼ IEEE 754 æŒ‡æ•¸è¦ +127 bias==

:::tip
Question 1: ç‚ºä»€éº¼ IEEE 754 æŒ‡æ•¸è¦ +127 bias ?

æ ¹æ“š [IEEE 754 Wiki](https://zh.wikipedia.org/wiki/IEEE_754)
>æ¡ç”¨æŒ‡æ•¸çš„å¯¦éš›å€¼åŠ ä¸Šå›ºå®šçš„åç§»å€¼çš„è¾¦æ³•è¡¨ç¤ºæµ®é»æ•¸çš„æŒ‡æ•¸ï¼Œå¥½è™•æ˜¯å¯ä»¥ç”¨é•·åº¦ç‚ºeå€‹ä½å…ƒçš„ç„¡ç¬¦è™Ÿæ•´æ•¸ä¾†è¡¨ç¤ºæ‰€æœ‰çš„æŒ‡æ•¸å–å€¼ï¼Œé€™ä½¿å¾—å…©å€‹æµ®é»æ•¸çš„æŒ‡æ•¸å¤§å°çš„æ¯”è¼ƒæ›´ç‚ºå®¹æ˜“ï¼Œå¯¦éš›ä¸Šå¯ä»¥æŒ‰ç…§å­—å…¸æ¬¡åºæ¯”è¼ƒå…©å€‹æµ®é»è¡¨ç¤ºçš„å¤§å°ã€‚

é—œéµæ˜¯åœ¨æ–¼ç„¡ç¬¦è™Ÿæ•´æ•¸(unsigned int)ï¼Œ+127 ç›¸ç•¶æŠŠå…¨éƒ¨çš„æ•¸å­—åšä¸€å€‹å¹³ç§»ï¼Œå…¨éƒ¨è®Šæˆæ­£æ•¸ï¼Œå°±å¾ˆå¥½åšæ¯”è¼ƒäº†ï¼Œåéä¾†èªªï¼Œè©¦æƒ³åŸæœ¬æ²’æœ‰åŠ  127, å¦‚æœæŒ‡æ•¸æœ‰æ­£æœ‰è² ï¼Œæ˜¯ sined bitsï¼Œå¦‚æœç•¶æˆ unsigned int ä¾†æ¯”è¼ƒæŒ‡æ•¸ä½ 8 bits, è² çš„é¦–ä½å…ƒæ˜¯ 1 ä¸€å®šæ¯”æ­£çš„å¤§ï¼Œæˆ‘å€‘æƒ³è¦floating points æ¯”è¼ƒæ™‚ç›´æ¥ç•¶ä½œ unsigned int æ¯”è¼ƒï¼Œå› æ­¤åŸæœ¬ -126(Question 2) ~ +127ï¼Œè®Šæˆ 1 (æœ€å°çš„æ­£è¦æ•¸) ~ 254(æœ€å¤§çš„æ­£è¦æ•¸)
:::

:::tip
Question 2: ç‚ºä½•æœ€å°æŒ‡æ•¸æ¬¡æ–¹ -126 ?

å› ç‚ºå¦‚æœæŒ‡æ•¸æ¬„ä½ 8 å€‹ bits å…¨éƒ½æ˜¯ 0ï¼Œ ä»£è¡¨éæ­£è¦åŒ–æ•¸ï¼Œæ‰€ä»¥æ­£è¦åŒ– exponent æ˜¯å¾ 00000001 é–‹å§‹ï¼Œæ‰£æ‰ 127 = -126
:::

### 1.3  çµè«–
* èª¤å·®ä¾†æº : æµ®é»æ•¸åé€²åˆ¶è½‰äºŒé€²åˆ¶ï¼Œä¸”åªæœ‰æœ‰é™æ¬„ä½è¡¨ç¤º
* æµ®é»æ•¸æ¬„ä½ç‚ºäº†å¤šä¸€ä½ç²¾åº¦ï¼Œå„²å­˜æ™‚æŠŠæœ€å‰é¢çš„ 1 æ¨å»ï¼Œä¹‹å¾Œæ›ç®—æ™‚è¦åŠ å›ä¾†
* æŒ‡æ•¸æ¬„ä½ + 127 : æ¯”è¼ƒå…©å€‹æµ®é»æ•¸å¤§å°æ™‚ï¼Œç‚ºäº†æ–¹ä¾¿ç›´æ¥æ¯”è¼ƒæŒ‡æ•¸ä½ï¼ŒæŠŠå…¨éƒ¨æ•¸å­—åšå¹³ç§»è®Šæˆ unsigned intï¼Œæ˜¯ä¸€å€‹é«˜ç«¯çš„æ‰‹æ³•ğŸ˜

----
## Chapter 2. å¯¦ä½œ ! æµ®é»æ•¸çš„è½‰æ›ç¨‹å¼

### 2.1 æµ®é»æ•¸è½‰æˆ IEEE 754 æ ¼å¼
::::tabs
::: tab python
```python
def float_2_IEEE754(float_num):
        bit_pattern = bitstring.BitArray(float=float_num, length=32)
        sign = bit_pattern.bin[0]   # 1 bit
        exp  = bit_pattern.bin[1:9] # 8 bits
        frac = bit_pattern.bin[9:]  # 23 bits
        print(f"Float number: {float_num}  ", sign, exp, frac, 
              f"Actually stored Value = {bit_pattern.float}")

float_2_IEEE754(0.1)
float_2_IEEE754(0.2)
float_2_IEEE754(0.3)
```
:::


::: tab console
```
Float number: 0.1   0 01111011 10011001100110011001101 Actually stored Value = 0.10000000149011612
Float number: 0.2   0 01111100 10011001100110011001101 Actually stored Value = 0.20000000298023224
Float number: 0.3   0 01111101 00110011001100110011010 Actually stored Value = 0.30000001192092896
```
:::
::::

ç•¶ç„¶ï¼Œé€™è£¡ä¹Ÿæœ‰ C èªè¨€çš„å¯¦ä½œæ–¹æ³•ï¼Œå°±æ˜¯ä½¿ç”¨åˆ°æˆ‘å€‘ä¸å¸¸ç”¨çš„ `union`ï¼Œå¯ä»¥è®“æˆ‘å€‘çš„å¿«é€Ÿå¾—åˆ°è©²æ¬„ä½çš„å€¼ã€‚é€™è£¡è¦æ³¨æ„çš„æ˜¯çµæ§‹é«”çš„å®£å‘Šï¼Œ==å› ç‚ºæˆ‘å€‘ç¾åœ¨é›»è…¦å¤§éƒ¨åˆ†æ˜¯ "little-endian"ï¼Œæ‰€ä»¥åœ¨å®£å‘Šæ¬„ä½æ™‚è¦æ³¨æ„æ¬„ä½é †åº!==

::::tabs
::: tab C
```C {3-10}
#include <stdio.h>

typedef union Float32 {
    struct {
        unsigned fraction : 23;
        unsigned exponent : 8 ;
        unsigned sign     : 1 ;
    };  
    float num;
}Float32;

void print_binary(unsigned int number)
{
    if (number >> 1) {
        print_binary(number >> 1);
    }
    putc((number & 1) ? '1' : '0', stdout);
}

int main()
{
    Float32 a;
    a.num = 0.1;
    printf("sign: ")    ;print_binary(a.sign)    ; printf(" ");
    printf("exponent: ");print_binary(a.exponent); printf(" ");
    printf("fraction: ");print_binary(a.fraction); printf(" \n");
    return 0;
}
```
:::

::: tab console
```
sign: 0 exponent: 01111011 fraction: 10011001100110011001101
```
::::

### 2.2 IEEE 754 æ ¼å¼è½‰æˆæµ®é»æ•¸ 
:::: tabs
::: tab python
```python
def bit_2_float(bit_string):
        sign = bit_string[0]   # 1 bit
        exp  = bit_string[1:9] # 8 bits
        frac = bit_string[9:]  # 23 bits

        power = int(exp, 2) - 127
        value = 0
        start = 1 # å¾ 1/2 ^ 1 é–‹å§‹
        for bit in frac:
                value += int(bit) * 0.5 ** start
                start += 1
        
        return ( 1 + value) * 2 ** power

test_bitstr = "00111110100110011001100110011010" # 0.3
bit_2_float(test_bitstr)
```
:::
::: tab console
```
0.30000001192092896
```
:::

::::

### 2.3 å¤šä¸€äº›äº›è§€å¯Ÿ
$\pm 0.0, \pm1.0$
:::: tabs
::: tab python
```python
float_2_IEEE754(+0.0)
float_2_IEEE754(-0.0)
float_2_IEEE754(+1.0) #  1.0 * 2 ** 0  (127 - 127)
float_2_IEEE754(-1.0) # -1.0 * 2 ** 0 (127 - 127)
```
:::
::: tab console
```
Float number:  0.0   0 00000000 00000000000000000000000 Actually stored Value =  0.0
Float number: -0.0   1 00000000 00000000000000000000000 Actually stored Value = -0.0
Float number:  1.0   0 01111111 00000000000000000000000 Actually stored Value =  1.0
Float number: -1.0   1 01111111 00000000000000000000000 Actually stored Value = -1.0
```
:::
::::

2. $Nan, inf$
:::: tabs
::: tab python
```python
import numpy as np
float_2_IEEE754(np.nan)
float_2_IEEE754(np.inf)
```
:::
::: tab console
```
Float number: nan   0 11111111 10000000000000000000000 Actually stored Value = nan
Float number: inf   0 11111111 00000000000000000000000 Actually stored Value = inf
```
:::

* not a number (nan) : æŒ‡æ•¸å…¨ç‚º 1 è€Œåˆ†æ•¸ä¸ç­‰æ–¼ 0ï¼Œè€Œä¸” nan != nan
* infinity : æŒ‡æ•¸å…¨ç‚º 1 è€Œ åˆ†æ•¸ç­‰æ–¼ 0
::::

----
## Chapter 3. 32 bits æµ®é»æ•¸çš„å®‰å…¨ç¯„åœ
### 3.1 æµ®é»æ•¸å®‰å…¨ç¯„åœ
ä¸€æ¨£å…ˆä¾†å€‹å°å°çš„éœ‡æ’¼æ•™è‚²ğŸ™‚

:::: tabs
::: tab python
```python
float_2_IEEE754(123456789)
```
:::

::: tab console
```
Float number: 123456789   0 10011001 11010110111100110100011 Actually stored Value = 123456792.0
```
:::

åœ¨æŒ‡å®š 32 bits æµ®é»æ•¸ç‚º 123456789 æ™‚ï¼Œå¯çœ‹åˆ°å¯¦éš›å„²å­˜ä¸æ˜¯123456789ï¼Œè€Œæ˜¯123456792ï¼Œç‚ºä»€éº¼ ?
::::


é¦–å…ˆæˆ‘å€‘è©¦è‘—æŠŠ 123456789 è½‰æˆäºŒé€²åˆ¶
:::: tabs
::: tab python
```python
test_str = bin(123456789)[2:] # remove 0b prefix
print(test_str, ", length is", len(test_str))
```
:::

::: tab console
```
111010110111100110100010101 , length is 27
```
:::

æˆ‘å€‘å¾—åˆ°äºŒé€²åˆ¶ï¼Œæ¥ä¸‹ä¾†å°±å¦‚ 1.1 é‚£é‚Šçš„æµç¨‹è½‰æˆ IEEE 754

::::
$$
123456789_{10}
= 111010110111100110100010101_{2}\\
= 1.11010110111100110100010101_{2}\times2^{26}
$$

é€™æ™‚å€™å°±æœƒç™¼ç¾ä¸€å€‹å•é¡Œï¼Œ1 å¾Œé¢æœ‰ 26 ä½æ•¸ï¼Œä½†æ˜¯æˆ‘å€‘çš„ IEEE 754 åªå…è¨± 23 å€‹ bitsã€‚é‚£å°±åªå¥½ ==æ¨å»3 bits ç²¾åº¦==
ç¹¼çºŒæ¨å°ï¼Œç”±ä¸Šå·²çŸ¥
* sign = 0
* exp = 26 + 127 = 153 ( 10011001 )
* frac = 7043491 ( 11010110111100110100010 )

æ‰€ä»¥ $123456789$  åœ¨IEEE 754 è¡¨ç¤ºç‚º $0 10011001 11010110111100110100011$ï¼Œç„¶è€Œå› ç‚ºæˆ‘å€‘ ==å‰›å‰›å› ç‚ºä½å…ƒæ•¸çš„é™åˆ¶ï¼Œæ¨å»ç²¾åº¦==
æ‰€ä»¥ç•¶æŠŠé€™å€‹ bitstring è½‰å›åŸæ•¸å€¼æ™‚


:::: tabs
::: tab python
```python
bit_2_float("01001100111010110111100110100011")
```
:::

::: tab console
```
123456792.0
```
:::

å¯ä»¥çœ‹åˆ°ï¼Œç”±æ–¼å‘ä¸Šæ¨å…¥ 3 bitsï¼Œé€ æˆä¸€äº›ç²¾åº¦è¢«ä¸Ÿå¤±ï¼Œæ‰€ä»¥ç„¡æ³•æ­£ç¢ºå„²å­˜ 123456789
::::

::: tip
Questions: å¦‚æœä½ è§€å¯Ÿåˆ°çš„è©±ï¼Œå› ç‚ºç²¾åº¦çš„æ¨å»ï¼Œæˆ‘å€‘æµ®é»æ•¸å…¶å¯¦æ˜¯é›¢æ•£çš„ï¼Œé›–ç„¶åœ¨å®‰å…¨ç¯„åœå…§æ˜¯é€£çºŒçš„ï¼Œä½†æ˜¯å®‰å…¨ç¯„åœå¤–å»æ˜¯é›¢æ•£çš„ï¼Œé‚£å®‰å…¨ç¯„åœæ˜¯ ?

åªè¦èƒ½åœ¨ 23 bits å…§è¡¨ç¤ºçš„è©± ( fraction 23 bits )ï¼Œé‚£å°±ä¸æœƒè¢«æ¨å…¥è€Œä¸Ÿå¤±ç²¾åº¦ï¼Œå› æ­¤ï¼Œå–®ç²¾åº¦å®‰å…¨ç¯„åœå…§æœ€å¤§æ•´æ•¸æ˜¯å¾Œé¢ 23 bits å…¨ 1 ( 8388607 ), 

$1.11111111111111111111111\times2^{23} = 16777215$
:::

:::: tabs
::: tab python
```python
int('1' * (23 + 1), 2) # æ•…æ„å¯« 1 + 23 å› ç‚ºæˆ‘å€‘è¦æŠŠ 1 åŠ å›ä¾†
```
:::
::: tab console
```
16777215
```
:::
::::

åªè¦å°æ–¼ç­‰æ–¼ $16777215$ æ•´æ•¸ç¯„åœå…§ï¼Œéƒ½æ˜¯é€£çºŒçš„ï¼Œæ¥ä¸‹ä¾†éƒ½æ˜¯é›¢æ•£çš„ï¼Œè«‹çœ‹ä¾‹å­

:::: tabs
::: tab python
```python
for i in range(10):
        value = 16777212 + i
        bit_pattern = bitstring.BitArray(float=value, length=32)
        store_value = bit_2_float(bit_pattern.bin)
        print(value, ":", store_value)
```
:::
::: tab console
```
16777212 : 16777212.0
16777213 : 16777213.0
16777214 : 16777214.0
16777215 : 16777215.0
16777216 : 16777216.0 <--- é–‹å§‹ç™¼æ•£
16777217 : 16777216.0
16777218 : 16777218.0
16777219 : 16777220.0
16777220 : 16777220.0
16777221 : 16777220.0
```
:::

å¯ä»¥çœ‹åˆ°å¾ 16777216 å°±é–‹å§‹é€æ¼¸ç™¼æ•£ !
æµ®é»æ•¸çœŸæ˜¯è¦è™•è™•å°å¿ƒç²¾åº¦é™·é˜±ï¼Œæ˜¯å§?ğŸ¤£
::::

### 3.2 æµ®é»æ•¸çš„å¯†åº¦ - çœ‹åœ–èªªæ•…äº‹
é€™è£¡ä¾†å±•ç¾å¹¾å¼µåœ–
![img](https://pic2.zhimg.com/80/v2-75cebc365c88cd9b8862e04ad3c52601_720w.png)
ä¸Šåœ–å¯ä»¥çœ‹åˆ°ï¼Œæµ®é»æ•¸éš¨è‘—è¶…éå®‰å…¨è·é›¢è¶Šå¤šï¼Œè¶ŠåŠ ç™¼æ•£ï¼Œè¡¨ç¤ºæµ®é»æ•¸ä¸¦éå‡å‹»åˆ†å¸ƒçš„ï¼Œæ•¸å€¼è¶Šå°ï¼Œæµ®é»æ•¸è¶Šå¤š(ä¸‹ä¸€ç« éæ­£è¦æµ®é»æ•¸å¯ä»¥çœ‹åˆ°)

![img](https://pic2.zhimg.com/v2-96e6fafa938a2578e22496b8daf82691_r.jpg)
ä¸Šåœ–å¯ä»¥çœ‹åˆ°ï¼Œæ©«è»¸æ˜¯æŒ‡æ•¸ï¼Œç¸±è»¸æ˜¯æµ®é»æ•¸å€¼ï¼Œéš¨è‘—æŒ‡æ•¸è¶Šå¤§ï¼Œæ•¸å€¼ä¹Ÿè·Ÿè‘—è¶Šå¤§ï¼ŒåŒæ™‚ä¹Ÿæ›´åŠ é›¢æ•£

æˆ‘å€‘ä¹Ÿå¯ä»¥å‹•æ‰‹ç”¨ python ç•«ç•«çœ‹
:::: tabs
::: tab python
```python
import seaborn as sns
significand_bits = 4

expon_max, expon_min = 4, -3
fp_numbers = []

for sign_bit in [1, 0]:
        for exp in range(expon_min, expon_max + 1):
                for bits in range(0, 2**significand_bits):
                        significand = (-1)**(sign_bit) * ( 1 + bits / 2**significand_bits ) * 2 ** exp
                        fp_numbers.append(significand)

fp_numbers = np.array(fp_numbers)

sns.set()
plt.plot(fp_numbers, np.ones_like(fp_numbers), "x")
plt.show()
```
:::

::: tab console
![](https://i.imgur.com/PhaDh7U.png)
:::
::::



## Chapter 4. éæ­£è¦(Denormalized)æµ®é»æ•¸

::: tip
ä¾†æ®µéæ­£è¦æµ®é»æ•¸çš„è‡ªä»‹

* å¦‚æœæµ®é»æ•¸çš„æŒ‡æ•¸éƒ¨åˆ†çš„ ç·¨ç¢¼å€¼æ˜¯0ï¼Œåˆ†æ•¸éƒ¨åˆ†éé›¶ï¼Œé‚£éº¼é€™å€‹æµ®é»æ•¸å°‡è¢«ç¨±ç‚ºéæ­£è¦å½¢å¼çš„æµ®é»æ•¸
* ä¸€èˆ¬æ˜¯æŸå€‹æ•¸å­—ç›¸ç•¶æ¥è¿‘é›¶æ™‚æ‰æœƒä½¿ç”¨éæ­£è¦æ ¼å¼ä¾†è¡¨ç¤ºã€‚
* IEEE 754æ¨™æº–è¦å®šï¼šéæ­£è¦çš„æµ®é»æ•¸çš„æŒ‡æ•¸åç§»å€¼æ¯”æ­£è¦å½¢å¼çš„æµ®é»æ•¸çš„æŒ‡æ•¸åç§»å€¼å°1ã€‚
* æ¼¸é€²å¼ä¸‹æº¢ä½ï¼ˆgradual underflowï¼‰
* ç”¨ä¾†è§£æ±ºå¡«è£œçµ•å°å€¼æ„ç¾©ä¸‹æœ€å°æ­£è¦æ•¸èˆ‡é›¶çš„è·é›¢ã€‚ï¼ˆèˆ‰ä¾‹èªªï¼Œæ­£æ•¸ä¸‹ï¼Œæœ€å¤§çš„éè¦æ ¼æ•¸ç­‰æ–¼æœ€å°çš„è¦æ ¼æ•¸ã€‚è€Œä¸€å€‹æµ®é»æ•¸ç·¨ç¢¼ä¸­ï¼Œå¦‚æœexponent=0ï¼Œä¸”å°¾æ•¸éƒ¨åˆ†ä¸ç‚ºé›¶ï¼Œé‚£éº¼å°±æŒ‰ç…§éæ­£è¦æµ®é»æ•¸ä¾†è§£æï¼‰
:::

ä»‹ç´¹å®Œäº†ï¼Œæ˜¯ä¸æ˜¯ä¼¼æ‡‚éæ‡‚å“ˆå“ˆğŸ¤£ï¼Œç°¡å–®ä¾†èªªï¼Œæˆ‘å€‘å¿…é ˆä½¿ç”¨éæ­£è¦åŒ–æµ®é»æ•¸ï¼Œ==ä½¿æœ€å°çš„æ­£è¦æ•¸èˆ‡ 0 çš„è·é›¢å¯ä»¥æ›´å¹³æ»‘ï¼Œé”åˆ°æ¼¸é€²å¼ä¸‹æº¢ä½ï¼Œè€Œåœ¨æ¼¸é€²0çš„éç¨‹ä¸­ï¼Œæˆ‘å€‘ä½¿ç”¨éæ­£è¦åŒ–æµ®é»æ•¸ï¼Œåˆå¯ä»¥å„²å­˜æ›´å°çš„æ•¸==ã€‚

é¦–å…ˆï¼Œå…ˆä¾†çœ‹æ­£è¦åŒ–æµ®é»æ•¸çš„æœ€å¤§å€¼èˆ‡æœ€å°å€¼

:::: tabs
::: tab python
```python
# min normalize number
float_2_IEEE754(2**-126)

# max normalize number
max_normal_float = bit_2_float("01111111011111111111111111111111")
float_2_IEEE754(max_normal_float)
```
::: tab console
```
Float number: 1.1754943508222875e-38   0 00000001 00000000000000000000000 Actually stored Value = 1.1754943508222875e-38
Float number: 3.4028234663852886e+38   0 11111110 11111111111111111111111 Actually stored Value = 3.4028234663852886e+38
```
::: tab console

:::
1. ç‚ºä»€éº¼æœ€å°æ˜¯ $2^{-126}$ ? å› ç‚º æŒ‡æ•¸åŸŸ $00000001_{2}$ ä¸èƒ½å†å¾€ä¸‹é™äº†ï¼Œå…¨éƒ¨éƒ½æ˜¯ 0 çš„è©±å°±æ˜¯éæ­£è¦åŒ–æµ®é»æ•¸

    * å› æ­¤å°æ–¼ $1.1754943508222875e^{-38}$ underflow

2. ç‚ºä»€éº¼æœ€å¤§æ˜¯ $0 11111110 11111111111111111111111_{2}$ ? å› ç‚ºæŒ‡æ•¸åŸŸä¸èƒ½å†ä¸Šå‡äº†ï¼ŒæŒ‡æ•¸åŸŸå…¨éƒ¨éƒ½æ˜¯ 1 ï¼Œå°æ•¸åŸŸå…¨0 å°±æ˜¯IEEE 754çš„ç„¡é™å¤§
    * å› æ­¤å¤§æ–¼ $3.4028234663852886e+38$ ç‚º overflow
::::

å†ä¾†çœ‹ç‚ºä»€éº¼è¦æåˆ° ==å¹³æ»‘==ï¼Œé€™è£¡å•é¡Œä¹Ÿå¯ä»¥åƒè€ƒ[é€™ç¯‡å•ç­”](https://www.quora.com/Why-is-2-149-the-smallest-normalized-gap-in-the-IEEE-754-single-precision-format)

æˆ‘å€‘å†ä¾†çœ‹æœ€å°åŠæ¬¡å°çš„æ­£è¦åŒ–æµ®é»æ•¸

* æœ€å°çš„æ­£è™Ÿæ­£è¦æµ®é»æ•¸ : 
Exp = 00000001, Frac = 00000000000000000000000 ---> $2^{-126}$
                                              
* æ¬¡å°çš„æ­£è™Ÿæ­£è¦æµ®é»æ•¸ : 
Exp = 00000001, Frac = 00000000000000000000001
$$
2^{-126}\times (1+ 2 ^{-23}) = 2^{-126} + 2^{-149}
$$ 

æ‰€ä»¥æœ€å°å’Œæ¬¡å°ç›¸å·® $2^{-149}$ï¼Œç„¶è€Œå¦‚æœä»Šå¤©æ²’æœ‰éæ­£è¦åŒ–æµ®é»æ•¸çš„åŠ å…¥ï¼Œæœ€å°çš„æ­£çš„æ­£è¦åŒ–æ•¸è·Ÿ 0 ç›¸å·® $2^{-126}$ï¼Œæ‰ä¸‹å»çš„è·é›¢çªç„¶è·é›¢å·®äº† $2^{23}$ï¼Œæœ‰æ²’æœ‰æ›´å„ªé›…çš„ä½œæ³• ? 

```mermaid
graph TD
    sec(æ¬¡å°æ­£è¦æ•¸) -- 2^-149 --> small(æœ€å°æ­£è¦æ•¸ 2^-126)-- 2^-126 --> zero(0)
```

ç­”æ¡ˆæ˜¯ï¼Œéæ­£è¦æµ®é»æ•¸çš„åŠ å…¥ï¼Œå¯ä»¥ä½¿æœ€å°çš„æ­£è¦åŒ–æµ®é»æ•¸ä¸æœƒ==æ€¥é½==é™ä½ï¼Œæœƒå¹³æ»‘çš„é™ä¸‹å»

|æµ®é»æ•¸|sign|exponent|fraction| å€¼ |
|------|------|------|------|-------|
|æ¬¡å°æ­£è¦åŒ–|0| 00000001 | 00000000000000000000001 | $(1+ 2 ^{-23}) \times 2^{-126} = 2^{-126} + 2^{-149}$|
|æœ€å°æ­£è¦åŒ–|0| 00000001 | 00000000000000000000000 | $2^{-126}$ |
|æœ€å¤§éæ­£è¦åŒ–|0|00000000| 11111111111111111111111 | $(1 - 2^{-23}) \times 2^{-126} = 2^{-126} - 2^{-149}$| 
|æœ€å°éæ­£è¦åŒ–|0|00000000| 00000000000000000000001 | $2^{-149}$|

ä½ å¯ä»¥ç™¼ç¾ç¾åœ¨æ¯å€‹æ•¸éƒ½æ˜¯ç›¸å·® $2^{-149}$ï¼Œä¸è«–æ˜¯
* æ¬¡å°æ­£è¦æ•¸ è·Ÿ æœ€å°æ­£è¦æ•¸
* æœ€å°æ­£è¦æ•¸ è·Ÿ æœ€å¤§éæ­£è¦åŒ–
* æœ€å°éæ­£è¦åŒ– è·Ÿ 0

é€™ç¨®å„ªç¾çš„è§£æ±ºæ–¹æ³•ï¼ŒçœŸçš„æ˜¯æ•¸å­¸ä¹‹ç¾!ğŸ˜‰

## Chapter 5. IEEE 754 ç¸½çµ
1. $F=(-1)^{S} * 2^{(E-127)}* (1 + \frac{M}{2^{23}})$
2. +127 bias æ˜¯ç‚ºäº†æ–¹ä¾¿ç›´æ¥å¾ bit string æ¯”è¼ƒæµ®é»æ•¸å¤§å°
3. æµ®é»æ•¸åœ¨å®‰å…¨ç¯„åœå…§æ˜¯é€£çºŒçš„ï¼Œè¶…å‡ºå®‰å…¨ç¯„åœå¤–æœƒç™¼æ•£
4. æµ®é»æ•¸ä¸æ˜¯å‡å‹»åˆ†å¸ƒï¼Œæ•¸å€¼è¶Šå°æµ®é»æ•¸è¶Šå¤š
5. éæ­£è¦æµ®é»æ•¸çš„å¼•é€²å„ªç¾çš„è§£æ±ºäº†æœ€å°æ­£è¦åŒ–æ­£æµ®é»æ•¸åˆ° 0 çš„è·é›¢çªç„¶ä¸‹é™çš„çª˜å¢ƒ

æœ€å¾Œï¼Œå¼•é€²ä¸€å¼µæ¼‚äº®çš„åœ–

![img](https://pic1.zhimg.com/v2-53e4a2b1c2d91a2581004f7511d78a50_r.jpg)
èªªæ˜ä¸€ä¸‹ ==æœ¬åœ–æ˜¯ Z å­—å‹å¢åŠ çš„==ï¼Œç¶ è‰²(0)æ¥è—è‰²(éæ­£è¦åŒ–æµ®é»æ•¸)å†æ¥ç´«è‰²(æœ€å°æ­£è¦åŒ–æµ®é»æ•¸)ï¼Œå€¼é€æ¼¸ä¸Šå‡ï¼Œä¾æ­¤é¡æ¨

1. é»ƒè‰²è¡¨ç¤ºç„¡é™å¤§ï¼Œexp å…¨ 1ï¼Œä¸” significand (fraction) å…¨ 0ã€‚
2. ç´…è‰²è¡¨ç¤º NaN ï¼Œexp å…¨ 1ï¼Œä¸” significand (fraction) ä¸å…¨ç‚º 0
3. é»‘è‰²ç‚ºæœ€å¤§æ­£è¦åŒ–æµ®é»æ•¸
4. ç´«è‰²(æœ€å°æ­£è¦åŒ–æµ®é»æ•¸)åˆ°ç¶ è‰²(0)å¤ªæ€¥ä¿ƒä¸‹é™äº†ï¼Œéœ€è¦è—è‰²(éæ­£è¦åŒ–æµ®é»æ•¸)çš„ç·©è¡æ…¢æ…¢é™ä¸‹å»(æ¼¸é€²å¼ä¸‹é™)

## åƒè€ƒé€£çµ
1. [æœ¬ç¯‡æ–‡ç«  jupyter notebook çš„å±•ç¤º](https://github.com/lovelessless99/IEEE_754_Tutorial/blob/master/Floating_Points.ipynb)
2. [æ¼‚äº®çš„æµ®é»æ•¸ç·´ç¿’ç¶²ç«™](https://float.exposed/0x50ffffff)
3. [å¾ IEEE 754 æ¨™æº–ä¾†çœ‹ç‚ºä»€éº¼æµ®é»èª¤å·®æ˜¯ç„¡æ³•é¿å…çš„](https://medium.com/starbugs/see-why-floating-point-error-can-not-be-avoided-from-ieee-754-809720b32175)
4. [IEEE 754 Wiki](https://zh.wikipedia.org/wiki/IEEE_754)
5. [IEEE-754 Floating Point Converter](https://www.h-schmidt.net/FloatConverter/IEEE754.html)
6. [IEEE 754 æµ®é»æ•¸æ¨™æº–](http://ieee-754.blogspot.com/)
7. [ieee-754 32 bit single precision exponent 126 instead of 127](https://stackoverflow.com/questions/46732247/ieee-754-32-bit-single-precision-exponent-126-instead-of-127) 
8. [æ­å¯†æµ®é»æ•¸](https://zhuanlan.zhihu.com/p/89320102)
9. [Why is 2^âˆ’149  the smallest normalized gap in the IEEE 754 single-precision format?](https://www.quora.com/Why-is-2-149-the-smallest-normalized-gap-in-the-IEEE-754-single-precision-format)